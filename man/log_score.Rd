% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/log_score.R
\name{log_score}
\alias{log_score}
\title{Compute logarithmic score for forecast}
\usage{
log_score(fcst, obs, summarize = TRUE, at = NULL, after = NULL, bw = NULL)
}
\arguments{
\item{fcst}{A forecast object (see output of \code{create_forecast()}).}

\item{obs}{An observations data frame.}

\item{summarize}{A boolean, defaults to TRUE. If TRUE, a single number will be returned as the score for the forecast.
If FALSE, a data frame with columns named \code{time}, \code{val_obs}, and \code{score} will be returned,
containing the scores for each individual time point.
This can be used by plotting functions to colour-code observations, for example.}

\item{at}{(Optional) A time (must be compatible with \code{fcst} and \code{obs}).
If specified, the score for this time point will be returned.
Mutually exclusive with \code{after}.}

\item{after}{(Optional) A number. If specified, the score at
time \code{fcst$forecast_time + after} will be returned.
Mutually exclusive with \code{at}.}

\item{bw}{(Optional) The bandwidth for calculating the Kernel Density Estimation (see \code{?scoringRules::logs_sample}).
If not provided, a bandwidth will automatically be calculated by \code{scoringRules::logs_sample()}.}
}
\value{
If \code{summarize} is \code{FALSE},
a data frame containing times, observations, and scores.
Otherwise, the score at the time speficied by either \code{at} or \code{after}.
}
\description{
Given a forecast and set of observations,
compute the log score for every time point.
Uses a Kernel Density Estimation (KDE) to interpolate the density
at the observation point.
}
\examples{
df <- data.frame(time=c(1,1,1,1,1,2,2,2,2,2,3,3,3,3,3), val=c(1:5, 1:5, 1:5))
# return a data frame
log_score(
  create_forecast(df),
  data.frame(time=1:3, val_obs=c(-1, 2.5, 5)),
  summarize=FALSE
)

# use `at` parameter to specify absolute times
log_score(
  create_forecast(df, forecast_time=1),
  data.frame(time=1:3, val_obs=c(-1, 2.5, 5)),
  at=2
)

# use `after` parameter to specify times relative to `forecast_time`
log_score(
  create_forecast(df, forecast_time=1),
  data.frame(time=1:3, val_obs=c(-1, 2.5, 5)),
  after=1
)
}
